@startuml

package cryptoservice {
    package boundary {
        package api {
            interface DecryptAPI <<REST API>> {
                +decryptPost(decryptRequest: DecryptRequest, principal: Principal): ResponseEntity
            }

            interface EncryptAPI <<REST API>> {
                +encryptPost(encryptRequest: EncryptRequest, principal: Principal): ResponseEntity
            }

            interface JwtManagementAPI <<REST API>> {
                +generateJwtPost(generateJwtRequest: GenerateJwtRequest, principal: Principal): ResponseEntity
            }

            interface KeyManagementAPI <<REST API>> {
                +generateKeyPost(principal: Principal): ResponseEntity
            }
        }

        package security {
            class DynamicUserDetailsService {
                - knownClientStore: KnownClientStore
                - request: HttpServletRequest
                +loadUserByUsername(username: String): UserDetails
                -isNewClient(username: String, path: String): boolean
            }

            class KnownClientStore {
                - knownClients: Set<String>
                +isKnown(cn: String): boolean
                +addClient(cn: String): void
            }

            class SecurityConfig {
                +securityFilterChain(http: HttpSecurity): SecurityFilterChain
            }
        }

        package validation {
            class DecryptValidator {
                - JWT_MAX_LENGTH: int
                - CIPHER_TEXT_MAX_LENGTH: int
                +validateDecryptRequest(request: DecryptRequest): void
            }

            class EncodingValidator {
                +validateNoUnicodeEscapes(field: String, name: String): void
            }

            class EncryptValidator {
                - PLAIN_TEXT_MAX_LENGTH: int
                - JWT_MAX_LENGTH: int
                +validateEncryptRequest(request: EncryptRequest): void
            }

            class FieldValidator {
                +validateNotBlank(field: String, name: String): void
                +validateMaxLength(field: String, maxLength: int, name: String): void
                +validateWhitelist(field: String, name: String): void
                +validateExtendedWhitelist(field: String, name: String): void
            }

            class JwtClaimsValidator {
                - MAX_LENGTH: int
                +validateAlgorithmFromHeader(alg: String): void
                +validateKeyAlias(alias: String): void
            }

            class JwtManagementValidator {
                - ISSUED_TO_MAX_LENGTH: int
                +validateGenerateJwtRequest(request: GenerateJwtRequest): void
            }

            class JwtValidator {
                +validateJwtPattern(jwt: String): void
                +validateSignature(jwt: String, key: SecretKey): Jws<Claims>
                +validateExpiration(expiration: Date): void
            }

            class ValidationService {
                +validateText(text: String, name: String, maxLength: int, extended: boolean): void
                +validateTextWithoutWhitelist(text: String, name: String, maxLength: int): void
                +validateJwt(jwt: String, key: SecretKey): void
            }
        }

        class Controller {
            +encryptPost(encryptRequest: EncryptRequest, principal: Principal): ResponseEntity<EncryptResponse>
            +decryptPost(decryptRequest: DecryptRequest, principal: Principal): ResponseEntity<DecryptResponse>
            +generateKeyPost(principal: Principal): ResponseEntity<GenerateKeyResponse>
            +generateJwtPost(generateJwtRequest: GenerateJwtRequest, principal: Principal): ResponseEntity<GenerateJwtResponse>
            +signCsrPost(signCsrRequest: SignCsrRequest): ResponseEntity<SignCsrResponse>
            +rootCaGet(): ResponseEntity<GetRootCaCertResponse>
            -checkClientNameExists(clientName: String): void
            -resolveClientName(principal: Principal): String
        }
    }

    package businessfacade {
        class DecryptFacade {
            +processDecryption(decryptRequest: DecryptRequest, clientName: String): ResponseEntity<DecryptResponse>
        }

        class EncryptFacade {
            +processEncryption(encryptRequest: EncryptRequest, clientName: String): ResponseEntity<EncryptResponse>
        }

        class JwtManagementFacade {
            +generateJwt(generateJwtRequest: GenerateJwtRequest, clientName: String): ResponseEntity<GenerateJwtResponse>
        }

        class KeyManagementFacade {
            +generateKey(clientName: String): ResponseEntity<GenerateKeyResponse>
        }
    }

    package businesslogic {
        package jwtmanagement {
            class JwtManagementService {
                +generateJwt(generateJwtModel: GenerateJwtModel): GenerateJwtResultModel
                +extractClientKeyAlias(jwtToken: String): String
                +extractIssuedTo(jwtToken: String): String
            }
        }

        package keymanagement {
            class ClientKeyRegistry {
                +hasClient(clientName: String): boolean
                +registerClientKey(clientName: String, keyAlias: String)
                +removeClientByKeyAlias(keyAlias: String)
                +getKeyAliasForClient(clientName: String): String
                +getClientNameByKeyAlias(keyAlias: String): String
                +getIvForClient(clientName: String): byte[]
                +updateIvForClient(clientName: String, iv: byte[])
            }

            class KeyCleanupTask {
                +cleanupKeysPeriodically(): void
                +cleanupExpiredKeys(): void
                -findExpiredAliases(keystore: KeyStore): List<String>
                -getAliases(keystore: KeyStore): Enumeration<String>
                -isReservedAlias(alias: String): boolean
                -deleteExpiredKeys(keystore: KeyStore, aliasesToDelete: List<String>): void
            }

            class KeyExpirationChecker {
                +isExpired(keystore: KeyStore, alias: String): boolean
                -getEntry(keystore: KeyStore, alias: String): KeyStore.Entry
                -getCreationDate(keystore: KeyStore, alias: String): Date
                -destroyProtection(protection: PasswordProtection, alias: String): void
            }

            class KeyManagementService {
                +generateKey(generateKeyModel: GenerateKeyModel): GenerateKeyResultModel
                -generateRandomKey(): SecretKey
                -generateRandomKeyAlias(): String
            }

            class KeyStoreHelper {
                +storeKey(alias: String, key: SecretKey): void
                +loadKeyStore(): KeyStore
                +saveKeyStore(keystore: KeyStore): void
                +getClientKey(alias: String): SecretKey
                +getKey(alias: String): SecretKey
            }

            class KeyStoreInitializer {
                - static final int KEY_SIZE
                - static final Logger LOGGER
                - keyStoreHelper: KeyStoreHelper
                +initKeyStore(): void
                -checkContainsAlias(alias: String): boolean
                -initJwtSigningKey(): void
                -initMasterKey(): void
            }

            class MasterKeyRotationTask {}
        }

        class DecryptService {}
        class EncryptService {}
    }

    package entity {
        package factory {}
            class ClientKeyDataFactory {}
            class ModelsFactory {}
            class ResponseFactory {}
            class ResultModelsFactory {}
        }

        package model {
            package decrypt {
                class DecryptModel {}
                class DecryptRequest {}
                class DecryptResponse {}
                class DecryptResultModel {}
            }

            package encrypt {
                class EncryptModel {}
                class EncryptRequest {}
                class EncryptResponse {}
                class EncryptResultModel {}
            }

            package jwtmanagement {
                class GenerateJwtModel {}
                class GenerateJwtRequest {}
                class GenerateJwtResponse {}
                class GenerateJwtResultsModel {}
            }

            package keymanagement {
                class ClientKeyData {}
                class GenerateKeyModel {}
                class GenerateKeyResponse {}
                class GenerateKeyResultsModel {}
            }
        }
    }

    package errorhandling {
        package exceptions {
            class ApiException {}
            class BadRequestException {}
            class InternalServerErrorException {}
        }

        package util {
            enum ErrorCode {}
            class ErrorDetail {}
            class ErrorDetailBuilder {}
            class ErrorResponse {}
        }

        class GlobalExceptionHandler {}
    }

    class CryptoserviceApplication {
        {static} +main(args: String[]): void
    }

    DecryptAPI --> DecryptRequest : uses
    DecryptAPI --> DecryptResponse : returns

    EncryptAPI --> EncryptRequest : uses
    EncryptAPI --> EncryptResponse : returns

    JwtManagementAPI --> GenerateJwtRequest : uses
    JwtManagementAPI --> GenerateJwtResponse : returns

    KeyManagementAPI --> GenerateKeyResponse : returns
}

@enduml